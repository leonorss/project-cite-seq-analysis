---
title: "scRNAseq analysis of Levesque’s data"
author: "Jonathan Haab"
date: "22 12 2020"
output: html_document
---
# from pipeline example described by Pierre-Luc Germain, course sta426 UZH

# Loading necessary libraries

```{r}
suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(scran)
  library(scater)
  library(batchelor)
  library(scDblFinder)
  library(sctransform)
  library(muscat)
  library(SEtools)
  library(cowplot)
  library(BiocParallel)
  library(ComplexHeatmap)
  
  library(DropletUtils) # for read10xCounts
  library(Matrix) # to handle sparse matrix
  library(BiocNeighbors) # for kNN graph
  library(igraph) # for cluster_louvain
})
```

# Preprocessing & Clustering

## Loading the data

```{r data-loading}
## data can be downloaded from : http://imlspenticton.uzh.ch/dump/files_for_levesque.tar

# set local path
local.path <- getwd()
setwd(local.path)
experiments <- array()

sample_names <- list("patient1_HS", "patient1_SCC", "patient2_HS", "patient2_AK")
patient1_HS.path <- file.path("data", "patient1_HS")
patient1_SCC.path <- file.path("data", "patient1_SCC")
patient2_HS.path <- file.path("data", "patient2_HS")
patient2_AK.path <- file.path("data", "patient2_AK")




# read in filtered data and create list of SingleCellExperiment objects
paths <- list(patient1_HS.path, patient1_SCC.path, patient2_HS.path, patient2_AK.path)
sces <- lapply(paths, function(i) read10xCounts(file.path(i, "outs/filtered_feature_bc_matrix"), col.names = TRUE))

#patient1_SCC.path <- file.path("data", "patient1_SCC")

fnameHS <- file.path(patient1_HS.path, "outs/filtered_feature_bc_matrix")
#fnameSCC <- file.path(patient1_SCC.path, "outs/filtered_feature_bc_matrix")

# single cell experiment
sce.patient1_HS <- read10xCounts(fnameHS, col.names=TRUE)
#sce.patient1_SCC <- read10xCounts(fnameSCC, col.names=TRUE)


#sce.patient1_HS
sce.patient1_HS
#sce.patient1_SCC
```

```{r split-data}
# only select the gene expression data, drop the antibody capture
#sces <- lapply(sces, function(i) i[rowData(i)$Type == "Gene Expression"])
#sce.patient1_HS <- sce.patient1_HS[rowData(sce.patient1_HS)$Type == "Gene Expression"]
#sce.patient1_SCC <- sce.patient1_SCC[rowData(sce.patient1_SCC)$Type == "Gene Expression"]

sces <- lapply(sces, function(i) splitAltExps(i, rowData(i)$Type))
#lapply(sces, function(i) counts(altExp(i)) <- as.matrix(counts(altExp(i))))

# Split the data, store ADT in alternative experiment
sce.patient1_HS <- splitAltExps(sce.patient1_HS, rowData(sce.patient1_HS)$Type)
#sce.patient1_SCC <- splitAltExps(sce.patient1_SCC, rowData(sce.patient1_SCC)$Type)

# Coerce sparse matrix for ADT into a dense matrix
counts(altExp(sce.patient1_HS)) <- as.matrix(counts(altExp(sce.patient1_HS)))
#counts(altExp(sce.patient1_SCC)) <- as.matrix(counts(altExp(sce.patient1_SCC)))

#TODO do we still need to the dense matrix ADT data?

```


## Normalization & reduction
Note : The presence of composition biases already implies strong differences in expression profiles, so changing the normalization strategy is unlikely to affect the outcome of a clustering procedure.

Library size normalization : assumes that there is no “imbalance” in the differentially expressed (DE) genes between any pair of cells. However, balanced DE is not generally present in scRNA-seq applications, which means that library size normalization may not yield accurate normalized expression values for downstream analyses. In practice, normalization accuracy is not a major consideration for exploratory scRNA-seq data analyses. Composition biases do not usually affect the separation of clusters, only the magnitude - and to a lesser extent, direction - of the log-fold changes between clusters or cell types. As such, library size normalization is usually sufficient in many applications where the aim is to identify clusters and the top markers that define each cluster.


```{r library_size_normalization, eval=FALSE}
#exlude genes that appeared in less than 5 cells
#sce.patient1_HS <- sce[rowData(sce.patient1_HS)$detected >= 5,]

keep_feature <- rowSums(counts(sce.patient1_HS) > 0) > 4
sce.patient1_HS <- sce.patient1_HS[keep_feature,]

lib.sf.HS <- librarySizeFactors(sce.patient1_HS)
summary(lib.sf.HS)
hist(log10(lib.sf.HS), xlab="Log10[Size factor]", col='grey80')
```


```{r scaling_logtransform, eval=FALSE}
set.seed(100)
clust.patient1_HS <- quickCluster(sce.patient1_HS) 
sce.patient1_HS <- computeSumFactors(sce.patient1_HS, cluster=clust.patient1_HS, min.mean=0.1)
# downsample to correct the effect of library size
sce.patient1_HS <- logNormCounts(sce.patient1_HS) 
#sce.patient1_HS <- logNormCounts(sce.patient1_HS, downsample=TRUE) 
assayNames(sce.patient1_HS)

sce.patient1_HS <- runPCA(sce.patient1_HS)
plotPCA(sce.patient1_HS)
```
=> log transfo doesn't give satisfying results, we'll try variance-stabilizing transformation

```{r vst}
# get rid of seldom detected genes
#keep_feature <- rowSums(counts(sce.patient1_HS) > 0) > 4
#sce.patient1_HS <- sce.patient1_HS[keep_feature,]

sces <- lapply(sces, function(i) i[(rowSums(counts(i) > 0) > 4),])

sce.patient1_HS <- sce.patient1_HS[(rowSums(counts(sce.patient1_HS) > 0) > 4),]
#sce.patient1_SCC <- sce.patient1_SCC[(rowSums(counts(sce.patient1_SCC) > 0) > 4),]

vsts <- lapply(sces, function(i) suppressWarnings(sctransform::vst(counts((i)))))

#vst.patient2_HS <- suppressWarnings(sctransform::vst(counts(sces[[3]])))

vst.patient1_HS <- suppressWarnings(sctransform::vst(counts(sce.patient1_HS)))
#vst.patient1_SCC <- suppressWarnings(sctransform::vst(counts(sce.patient1_SCC)))

#logcounts(sce.patient1_HS) <- as.matrix(logcounts(sce.patient1_HS))
#nrow(vst.patient1_HS$y)
#ncol(vst.patient1_HS$y)
#nrow(counts(sce.patient1_HS))
```

```{r highly-variable-genes}
hvgs <- list()
for (i in seq_along(sces)) {
  logcounts(sces[[i]], withDimnames=FALSE) <- vsts[[i]]$y
  hvgs[[i]] <- row.names(sces[[i]])[order(vsts[[i]]$gene_attr$residual_variance, decreasing=TRUE)[1:2000]]
}

logcounts(sce.patient1_HS, withDimnames=FALSE) <- vst.patient1_HS$y
#logcounts(sce.patient1_SCC, withDimnames=FALSE) <- vst.patient1_SCC$y

#assay(sce.patient1_HS, "vst") <- vst.patient1_HS$y
assays(sce.patient1_HS)
#assays(sce.patient1_SCC)

# get highly-variable genes
hvg.patient1_HS <- row.names(sce.patient1_HS)[order(vst.patient1_HS$gene_attr$residual_variance, decreasing=TRUE)[1:2000]]
#hvg.patient1_SCC <- row.names(sce.patient1_SCC)[order(vst.patient1_SCC$gene_attr$residual_variance, decreasing=TRUE)[1:2000]]
```

```{r pca}
# run PCA
pc.vars <- list()
for (i in seq_along(sces)) {
  #check the right number of PCs to use with variance explained
  sces[[i]] <- runPCA(sces[[i]], subset_row=hvgs[[i]])
  pc.vars[[i]] <- attr(reducedDim(sces[[i]]), "percentVar")
  plot(pc.vars[[i]], xlab="PCs", ylab="% variance explained")
  # restrict to the first 20 components:
  reducedDim(sces[[i]]) <- reducedDim(sces[[i]])[,1:20]
  # run and plot 2d projections based on the PCA:
  sces[[i]] <- runTSNE(sces[[i]], dimred="PCA")
  sces[[i]] <- runUMAP(sces[[i]], dimred="PCA")
  
}
sce.patient1_HS <- runPCA(sce.patient1_HS, subset_row=hvg.patient1_HS)
#sce.patient1_SCC <- runPCA(sce.patient1_SCC, subset_row=hvg.patient1_SCC)

# check the variance explained by the PCs:
pc.var.patient1_HS <- attr(reducedDim(sce.patient1_HS),"percentVar")
plot(pc.var.patient1_HS, xlab="PCs", ylab="% variance explained")

#pc.var.patient1_SCC <- attr(reducedDim(sce.patient1_SCC),"percentVar")
#plot(pc.var.patient1_SCC, xlab="PCs", ylab="% variance explained")

# restrict to the first 20 components:
reducedDim(sce.patient1_HS) <- reducedDim(sce.patient1_HS)[,1:20]
#reducedDim(sce.patient1_SCC) <- reducedDim(sce.patient1_SCC)[,1:20]

# run and plot 2d projections based on the PCA:
sce.patient1_HS <- runTSNE(sce.patient1_HS, dimred="PCA")
sce.patient1_HS <- runUMAP(sce.patient1_HS, dimred="PCA")

#sce.patient1_SCC <- runTSNE(sce.patient1_SCC, dimred="PCA")
#sce.patient1_SCC <- runUMAP(sce.patient1_SCC, dimred="PCA")

```

## Clustering

```{r clustering}

  g.patient1_HS  <- buildKNNGraph(sce.patient1_HS, BNPARAM=AnnoyParam(), use.dimred="PCA", k=30)
#g.patient1_SCC <- buildKNNGraph(sce.patient1_SCC, BNPARAM=AnnoyParam(), use.dimred="PCA", k=30)

  sce.patient1_HS$cluster <- as.factor(cluster_louvain(g.patient1_HS)$membership)
#sce.patient1_SCC$cluster <- as.factor(cluster_louvain(g.patient1_SCC)$membership)

  plot_grid( plotTSNE(sce.patient1_HS, colour_by="cluster", text_by="cluster"), plotUMAP(sce.patient1_HS, colour_by="cluster", text_by="cluster") )
#plot_grid( plotTSNE(sce.patient1_SCC, colour_by="cluster", text_by="cluster"), plotUMAP(sce.patient1_SCC, colour_by="cluster", text_by="cluster") )

```

```{r clustering2}
graphs <- list()


for (i in seq_along(sces)) {
  graphs[[i]]  <- buildKNNGraph(sces[[i]], BNPARAM=AnnoyParam(), use.dimred="PCA", k=30)
#g.patient1_SCC <- buildKNNGraph(sce.patient1_SCC, BNPARAM=AnnoyParam(), use.dimred="PCA", k=30)

  sces[[i]]$cluster <- as.factor(cluster_louvain(graphs[[i]])$membership)
#sce.patient1_SCC$cluster <- as.factor(cluster_louvain(g.patient1_SCC)$membership)

  print(sample_names[[i]])
  pgrid <- plot_grid( plotTSNE(sces[[i]], colour_by="cluster", text_by="cluster") + ggtitle(sample_names[[i]]), plotUMAP(sces[[i]], colour_by="cluster", text_by="cluster") + ggtitle(sample_names[[i]]) )
  print(pgrid)
  
#plot_grid( plotTSNE(sce.patient1_SCC, colour_by="cluster", text_by="cluster"), plotUMAP(sce.patient1_SCC, colour_by="cluster", text_by="cluster") )
}
```

# Cluster annotation

## Known markers

```{r}
#head(sce.patient1_HS)
# access gene name, 21242 elements
#rowData(sce.patient1_HS)$ID
#rownames(sce.patient1_HS)
# acces marker name, 21242 elements
#rowData(sce.patient1_HS)$Symbol

genes <- list(
  # classification: https://www.sciencedirect.com/science/article/pii/S0923181120301985?via%3Dihub#bib0050
  # KERATINOCYTE
  keratinocyte = c("DSC3","DSP","LGALS7"),
  #keratinocyte_basal = c("KRT5","KRT14","COL17A1"),
  #keratinocyte_suprabasal = c("KRT1","KRT10"),
  #keratinocyte_differentiated = c("LOR", "SPINK5"),
  #keratinocyte_ORS = c("KRT6B"),
  #keratinocyte_channel = c("GJB2","GJB6","ATP1B1"),
  #keratinocyte_sebaceous_gland = c("MGST1","FASN"),
  #keratinocyte_sweat_gland  = c("DCD","AQP5"),
  # FIBROBLAST
  fibroblast  = c("DCDN","LUM","MMP2"),
  # fibroblast subclassification  from: https://www.nature.com/articles/s42003-020-0922-4#
  #fibroblast_secretory_reticular = c("WISP2","SLPI","CTHRC1","MFAP5","TSPAN8"),
  #fibroblast_proinflammatory = c("CCL19","APOE","CXCL2","CXCL3","EFEMP1"),
  #fibroblast_secretory_papillary = c("APCDD1","ID1","WIF1","COL18A1","PTGDS"),
  #fibroblast_mesenchymal = c("ASPN","POSTN","GPC3","TNN","SFRP1"),
  # PERICYTE & vSMC
  pericytevSMC  = c("ACTA2","TAGLN"), #vSMC : vascular smooth muscel cell
  #pericytevSMC_pericyte  = c("RGS5"),
  #pericytevSMC_vSMC  = c("MYL9","TPM2","RERGL"),
  # ENDOTHELIAL CELL
  endothelial  = c("PECAM1","SELE","CLDN5","VWF"),
  #endothelial_lymphatic  = c("PROX1","LYVE1"),
  # MYELOID CELL
  myeloid  = c("HLA-DRA","FCER1G","TYROBP","AIF1"),
  #myeloid_dendritic  = c("CD1C"),
  #myeloid_langerhans  = c("CD207"),
  #myeloid_macrophage = c("CD68","RNASE1","SEPP1","ITGAX"),
  # LYMPHOCYTE
  lymphocyte  = c("CD3D","CD3E","CD52","IL7R"),
  # MELANOCYTE
  melanocyte  = c("DCT","MLANA","PMEL","TYP1"),
  # SCHWANN CELL
  schwann  = c("CDH19","NGFR"),
  # MITOTIC CELL
  mitotic  = c("UBE2C","PCNA")
)

kms <- list()
for(i in seq_along(sces)){
  rownames(sces[[i]]) <- paste(rownames(sces[[i]]), rowData(sces[[i]])$Symbol, sep = ".")
  graph_unit <- graphs[[i]]
  kms[[i]] <- lapply(genes, FUN=function(graph_unit) grep(paste0(graph_unit, "$", collapse="|"), rownames(sces[[i]]), value=TRUE))
}

# since the row.names of the object have also the ensembl id, we find the matching row names for each gene:
rownames(sce.patient1_HS) <- paste(rownames(sce.patient1_HS), rowData(sce.patient1_HS)$Symbol, sep = ".")
#rownames(sce.patient1_SCC) <- paste(rownames(sce.patient1_SCC), rowData(sce.patient1_SCC)$Symbol, sep = ".")

#rownames(sce.patient1_HS)
km.patient1_HS <- lapply(genes, FUN=function(g.patient1_HS) grep(paste0(g.patient1_HS, "$", collapse="|"), rownames(sce.patient1_HS), value=TRUE))
#km.patient1_SCC <- lapply(genes, FUN=function(g.patient1_SCC) grep(paste0(g.patient1_SCC, "$", collapse="|"), rownames(sce.patient1_SCC), value=TRUE))
```

## Pseudo-bulk aggregation

```{r, eval=FALSE}
# mean logcounts by cluster:
pb.patient1_HS <- aggregateData(sce.patient1_HS, "logcounts", by=c("cluster"), fun="mean")
#pb.patient1_SCC <- aggregateData(sce.patient1_SCC, "logcounts", by=c("cluster"), fun="mean")

# build a heatmap of the mean logcounts of the known markers:
h.patient1_HS <- pheatmap(assay(pb.patient1_HS)[unlist(km.patient1_HS),], annotation_row=data.frame(row.names=unlist(km.patient1_HS), type=rep(names(km.patient1_HS), lengths(km.patient1_HS))), split=rep(names(km.patient1_HS), lengths(km.patient1_HS)), cluster_rows=FALSE, scale="row")
h.patient1_HS

#h.patient1_SCC <- pheatmap(assay(pb.patient1_SCC)[unlist(km.patient1_SCC),], annotation_row=data.frame(row.names=unlist(km.patient1_SCC), type=rep(names(km.patient1_SCC), lengths(km.patient1_SCC))), split=rep(names(km.patient1_SCC), lengths(km.patient1_SCC)), cluster_rows=FALSE, scale="row")
#h.patient1_SCC

# heatmap for the de-novo markers:
#h2 <- pheatmap(assay(pb.patient1_HS)[markers,], scale="row")
#h2
```

```{r heatmaps}

pbs <- list()
mats <- list()
cl2s <- list()
for (i in seq_along(sces))
{
  # mean logcounts by cluster:
  pbs[[i]] <- aggregateData(sces[[i]], "logcounts", by=c("cluster"), fun="mean")
  #pb.patient1_SCC <- aggregateData(sce.patient1_SCC, "logcounts", by=c("cluster"), fun="mean")
  
  # we will assign clusters to the cell type whose markers are the most expressed
  
  # we extract the pseudo-bulk counts of the markers for each cluster
  mats[[i]] <- assay(pbs[[i]])[unlist(km.patient1_HS),]
  #mat.patient1_SCC <- assay(pb.patient1_SCC)[unlist(km.patient1_SCC),]
  
  # we aggregate across markers of the same type
  mats[[i]] <- aggregate(t(scale(t(mats[[i]]))), by=list(type=rep(names(km.patient1_HS), lengths(km.patient1_HS))), FUN=sum)
  #mat.patient1_SCC <- aggregate(t(scale(t(mat.patient1_SCC))), by=list(type=rep(names(km.patient1_SCC), lengths(km.patient1_SCC))), FUN=sum)
  
  # for each column (cluster), we select the row (cell type) which has the maximum aggregated value
  cl2.patient1_HS <- mats[[i]][,1][apply(mats[[i]][,-1], 2, FUN=which.max)]
  # we convert the cells' cluster labels to cell type labels:
  sces[[i]]$cluster2 <- cl2.patient1_HS[sces[[i]]$cluster]
  
  # we aggregate again to pseudo-bulk using the new clusters
  pbs[[i]] <- aggregateData(sces[[i]], "logcounts", by=c("cluster2"), fun="mean")
  # we plot again the expression of the markers as a sanity check
  h1 <- pheatmap(assay(pbs[[i]])[unlist(km.patient1_HS),], annotation_row=data.frame(row.names=unlist(km.patient1_HS), type=rep(names(km.patient1_HS), lengths(km.patient1_HS))), split=rep(names(km.patient1_HS), lengths(km.patient1_HS)), cluster_rows=FALSE, scale="row", main=sample_names[[i]])
  print(h1)
  p <- plotUMAP(sces[[i]], colour_by="cluster2", text_by="cluster2", point_size=1) + ggtitle(sample_names[[i]])
  plot(p)
  #plotUMAP(sces[[i]], colour_by="cluster2", point_size=1)
}

# # mean logcounts by cluster:
# pb.patient1_HS <- aggregateData(sce.patient1_HS, "logcounts", by=c("cluster"), fun="mean")
# #pb.patient1_SCC <- aggregateData(sce.patient1_SCC, "logcounts", by=c("cluster"), fun="mean")
# 
# # we will assign clusters to the cell type whose markers are the most expressed
# 
# # we extract the pseudo-bulk counts of the markers for each cluster
# mat.patient1_HS <- assay(pb.patient1_HS)[unlist(km.patient1_HS),]
# #mat.patient1_SCC <- assay(pb.patient1_SCC)[unlist(km.patient1_SCC),]
# 
# # we aggregate across markers of the same type
# mat.patient1_HS <- aggregate(t(scale(t(mat.patient1_HS))), by=list(type=rep(names(km.patient1_HS), lengths(km.patient1_HS))), FUN=sum)
# #mat.patient1_SCC <- aggregate(t(scale(t(mat.patient1_SCC))), by=list(type=rep(names(km.patient1_SCC), lengths(km.patient1_SCC))), FUN=sum)
# 
# # for each column (cluster), we select the row (cell type) which has the maximum aggregated value
# cl2.patient1_HS <- mat.patient1_HS[,1][apply(mat.patient1_HS[,-1], 2, FUN=which.max)]
# # we convert the cells' cluster labels to cell type labels:
# sce.patient1_HS$cluster2 <- cl2.patient1_HS[sce.patient1_HS$cluster]
# 
# # we aggregate again to pseudo-bulk using the new clusters
# pb.patient1_HS <- aggregateData(sce.patient1_HS, "logcounts", by=c("cluster2"), fun="mean")
# # we plot again the expression of the markers as a sanity check
# h1 <- pheatmap(assay(pb.patient1_HS)[unlist(km.patient1_HS),], annotation_row=data.frame(row.names=unlist(km.patient1_HS), type=rep(names(km.patient1_HS), lengths(km.patient1_HS))), split=rep(names(km.patient1_HS), lengths(km.patient1_HS)), cluster_rows=FALSE, scale="row")
# h1
# plotUMAP(sce.patient1_HS, colour_by="cluster2", text_by="cluster2", point_size=1)
# #plotUMAP(sce.patient1_HS, colour_by="cluster2", point_size=1)

```

# Sub population
```{r subpopulations}
kera_sces <- list()
kera_hgvs <- list()
kera_vst <- list()
kera.pc.var <- list()
kera_graphs <- list()
kera_pbs <- list()
kera_kms <- list()

genes.kera <- list(
    # classification: https://www.sciencedirect.com/science/article/pii/S0923181120301985?via%3Dihub#bib0050
    # KERATINOCYTE
    #keratinocyte = c("DSC3","DSP","LGALS7"),
    keratinocyte_basal = c("KRT5","KRT14","COL17A1"),
    keratinocyte_suprabasal = c("KRT1","KRT10"),
    keratinocyte_differentiated = c("LOR", "SPINK5"),
    keratinocyte_ORS = c("KRT6B"),
    keratinocyte_channel = c("GJB2","GJB6","ATP1B1"),
    keratinocyte_sebaceous_gland = c("MGST1","FASN"),
    keratinocyte_sweat_gland  = c("DCD","AQP5")
    )

for(i in seq_along(sces)) {
    # select the cell labeled as keratinocytes in the previous step
  kera_sces[[i]] <- sces[[i]][sces[[i]]$cluster2=="keratinocyte"]
  
  #---- run the pipeline again on that subdataset
  
  kera_sces[[i]] <- kera_sces[[i]][(rowSums(counts(kera_sces[[i]]) > 0) > 4),]
  
  kera_vst[[i]] <- suppressWarnings(sctransform::vst(counts(kera_sces[[i]])))
  
  logcounts(kera_sces[[i]], withDimnames=FALSE) <- kera_vst[[i]]$y
  
  # get highly-variable genes
  kera_hgvs[[i]] <- row.names(kera_sces[[i]])[order(kera_vst[[i]]$gene_attr$residual_variance, decreasing=TRUE)[1:2000]]
  
  #---- pca
  
  kera_sces[[i]] <- runPCA(kera_sces[[i]], subset_row=kera_hgvs[[i]])
  
  # check the variance explained by the PCs:
  kera.pc.var[[i]] <- attr(reducedDim(kera_sces[[i]]),"percentVar")
  plot(kera.pc.var[[i]], xlab="PCs", ylab="% variance explained")
  
  # restrict to the first 20 components:
  reducedDim(kera_sces[[i]]) <- reducedDim(kera_sces[[i]])[,1:10]
  
  # run and plot 2d projections based on the PCA:
  kera_sces[[i]] <- runTSNE(kera_sces[[i]], dimred="PCA")
  kera_sces[[i]] <- runUMAP(kera_sces[[i]], dimred="PCA")
  
  #--- clustering
  
  kera_graphs[[i]] <- buildKNNGraph(kera_sces[[i]], BNPARAM=AnnoyParam(), use.dimred="PCA", k=30)
  
  
  kera_g <- graphs[[i]]
  kera_kms[[i]] <- lapply(genes.kera, FUN=function(kera_g) grep(paste0(kera_g, "$", collapse="|"), rownames(kera_sces[[i]]), value=TRUE))
  
  #---
  
  # mean logcounts by cluster:
  kera_pbs[[i]] <- aggregateData(kera_sces[[i]], "logcounts", by=c("cluster"), fun="mean")
  
  # we will assign clusters to the cell type whose markers are the most expressed
  # we extract the pseudo-bulk counts of the markers for each cluster
  mat.patient1_HS.kera <- assay(kera_pbs[[i]])[unlist(kera_kms[[i]]),]
  
  # we aggregate across markers of the same type
  mat.patient1_HS.kera <- aggregate(t(scale(t(mat.patient1_HS.kera))), by=list(type=rep(names(kera_kms[[i]]), lengths(kera_kms[[i]]))), FUN=sum)
  
  # for each column (cluster), we select the row (cell type) which has the maximum aggregated value
  cl.patient1_HS.kera <- mat.patient1_HS.kera[,1][apply(mat.patient1_HS.kera[,-1], 2, FUN=which.max)]
  # we convert the cells' cluster labels to cell type labels:
  kera_sces[[i]]$cluster <- cl.patient1_HS.kera[kera_sces[[i]]$cluster]
  
  # we aggregate again to pseudo-bulk using the new clusters
  kera_pbs[[i]] <- aggregateData(kera_sces[[i]], "logcounts", by=c("cluster"), fun="mean")
  # we plot again the expression of the markers as a sanity check
  h1.kera <- pheatmap(assay(kera_pbs[[i]])[unlist(kera_kms[[i]]),], annotation_row=data.frame(row.names=unlist(kera_kms[[i]]), type=rep(names(kera_kms[[i]]), lengths(kera_kms[[i]]))), split=rep(names(kera_kms[[i]]), lengths(kera_kms[[i]])), cluster_rows=FALSE, scale="row", main=sample_names[[i]])
  print(h1)
  p <- plotUMAP(kera_sces[[i]], colour_by="cluster", text_by="cluster", point_size=1) + ggtitle(sample_names[[i]])
  print(p)
  #plot_grid( plotTSNE(kera_sces[[i]], colour_by="cluster", text_by="cluster"), plotUMAP(kera_sces[[i]], colour_by="cluster", text_by="cluster") )
  
  
  #--- check if the markers we're defining the keratinocyte subpopulations are present in the cells
  # selecter by the keratinocyte cluster
  markers_kera_cluster <- rowData(kera_sces[[i]])$Symbol
  markers_kera <- c("DSC3","DSP","LGALS7","KRT5","KRT14","COL17A1","KRT1","KRT10","LOR", "SPINK5","KRT6B","GJB2","GJB6","ATP1B1","MGST1","FASN","DCD","AQP5")
  
  for (i in 1:length(markers_kera)) {
    idx <- grep(markers_kera_cluster[i], markers_kera, fixed=TRUE)
  
    found <- c()
    not_found <- c()
    
    if (any(is.na(idx))) {
      not_found <- c(not_found, markers_kera[i])
    } else {
      found <- c(found, markers_kera[i])
    }
  }
  
  print(paste("Done:", length(not_found), "/", length(markers_kera), "markers not found"))
}
  



#only patient1_HS, probably DELETE
# select the cell labeled as keratinocytes in the previous step
# sce.patient1_HS.kera <- sce.patient1_HS[sce.patient1_HS$cluster2=="keratinocyte"]
# 
# #---- run the pipeline again on that subdataset
# 
# sce.patient1_HS.kera <- sce.patient1_HS.kera[(rowSums(counts(sce.patient1_HS.kera) > 0) > 4),]
# 
# vst.patient1_HS.kera <- suppressWarnings(sctransform::vst(counts(sce.patient1_HS.kera)))
# 
# logcounts(sce.patient1_HS.kera, withDimnames=FALSE) <- vst.patient1_HS.kera$y
# 
# # get highly-variable genes
# hvg.patient1_HS.kera <- row.names(sce.patient1_HS.kera)[order(vst.patient1_HS.kera$gene_attr$residual_variance, decreasing=TRUE)[1:2000]]
# 
# #---- pca
# 
# sce.patient1_HS.kera <- runPCA(sce.patient1_HS.kera, subset_row=hvg.patient1_HS.kera)
# 
# # check the variance explained by the PCs:
# pc.var.patient1_HS.kera <- attr(reducedDim(sce.patient1_HS.kera),"percentVar")
# plot(pc.var.patient1_HS.kera, xlab="PCs", ylab="% variance explained")
# 
# # restrict to the first 20 components:
# reducedDim(sce.patient1_HS.kera) <- reducedDim(sce.patient1_HS.kera)[,1:10]
# 
# # run and plot 2d projections based on the PCA:
# sce.patient1_HS.kera <- runTSNE(sce.patient1_HS.kera, dimred="PCA")
# sce.patient1_HS.kera <- runUMAP(sce.patient1_HS.kera, dimred="PCA")
# 
# #--- clustering
# 
# g.patient1_HS.kera <- buildKNNGraph(sce.patient1_HS.kera, BNPARAM=AnnoyParam(), use.dimred="PCA", k=30)
# 
# genes.kera <- list(
#   # classification: https://www.sciencedirect.com/science/article/pii/S0923181120301985?via%3Dihub#bib0050
#   # KERATINOCYTE
#   #keratinocyte = c("DSC3","DSP","LGALS7"),
#   keratinocyte_basal = c("KRT5","KRT14","COL17A1"),
#   keratinocyte_suprabasal = c("KRT1","KRT10"),
#   keratinocyte_differentiated = c("LOR", "SPINK5"),
#   keratinocyte_ORS = c("KRT6B"),
#   keratinocyte_channel = c("GJB2","GJB6","ATP1B1"),
#   keratinocyte_sebaceous_gland = c("MGST1","FASN"),
#   keratinocyte_sweat_gland  = c("DCD","AQP5")
#   )
# 
# km.patient1_HS.kera <- lapply(genes.kera, FUN=function(g.patient1_HS.kera) grep(paste0(g.patient1_HS.kera, "$", collapse="|"), rownames(sce.patient1_HS.kera), value=TRUE))
# 
# #---
# 
# # mean logcounts by cluster:
# pb.patient1_HS.kera <- aggregateData(sce.patient1_HS.kera, "logcounts", by=c("cluster"), fun="mean")
# 
# # we will assign clusters to the cell type whose markers are the most expressed
# # we extract the pseudo-bulk counts of the markers for each cluster
# mat.patient1_HS.kera <- assay(pb.patient1_HS.kera)[unlist(km.patient1_HS.kera),]
# 
# # we aggregate across markers of the same type
# mat.patient1_HS.kera <- aggregate(t(scale(t(mat.patient1_HS.kera))), by=list(type=rep(names(km.patient1_HS.kera), lengths(km.patient1_HS.kera))), FUN=sum)
# 
# # for each column (cluster), we select the row (cell type) which has the maximum aggregated value
# cl.patient1_HS.kera <- mat.patient1_HS.kera[,1][apply(mat.patient1_HS.kera[,-1], 2, FUN=which.max)]
# # we convert the cells' cluster labels to cell type labels:
# sce.patient1_HS.kera$cluster <- cl.patient1_HS.kera[sce.patient1_HS.kera$cluster]
# 
# # we aggregate again to pseudo-bulk using the new clusters
# pb.patient1_HS.kera <- aggregateData(sce.patient1_HS.kera, "logcounts", by=c("cluster"), fun="mean")
# # we plot again the expression of the markers as a sanity check
# h1.kera <- pheatmap(assay(pb.patient1_HS.kera)[unlist(km.patient1_HS.kera),], annotation_row=data.frame(row.names=unlist(km.patient1_HS.kera), type=rep(names(km.patient1_HS.kera), lengths(km.patient1_HS.kera))), split=rep(names(km.patient1_HS.kera), lengths(km.patient1_HS.kera)), cluster_rows=FALSE, scale="row")
# h1
# plotUMAP(sce.patient1_HS.kera, colour_by="cluster", text_by="cluster", point_size=1)
# #plot_grid( plotTSNE(sce.patient1_HS.kera, colour_by="cluster", text_by="cluster"), plotUMAP(sce.patient1_HS.kera, colour_by="cluster", text_by="cluster") )
# 
# 
# #--- check if the markers we're defining the keratinocyte subpopulations are present in the cells
# # selecter by the keratinocyte cluster
# markers_kera_cluster <- rowData(sce.patient1_HS.kera)$Symbol
# markers_kera <- c("DSC3","DSP","LGALS7","KRT5","KRT14","COL17A1","KRT1","KRT10","LOR", "SPINK5","KRT6B","GJB2","GJB6","ATP1B1","MGST1","FASN","DCD","AQP5")
# 
# for (i in 1:length(markers_kera)) {
#   idx <- grep(markers_kera_cluster[i], markers_kera, fixed=TRUE)
# 
#   found <- c()
#   not_found <- c()
#   
#   if (any(is.na(idx))) {
#     not_found <- c(not_found, markers_kera[i])
#   } else {
#     found <- c(found, markers_kera[i])
#   }
# }
# 
# print(paste("Done:", length(not_found), "/", length(markers_kera), "markers not found"))
# ```
# 
# ```{r check_markers, eval=FALSE}
# data_markers <- rowData(sce.patient1_HS)$Symbol
# known_markers <- c("DSC3","DSP","LGALS7","KRT5","KRT14","COL17A1","KRT1","KRT10","LOR", "SPINK5","KRT6B","GJB2","GJB6","ATP1B1","MGST1","FASN","DCD","AQP5","DCDN","LUM","MMP2","WISP2","SLPI","CTHRC1","MFAP5","TSPAN8","CCL19","APOE","CXCL2","CXCL3","EFEMP1","APCDD1","ID1","WIF1","COL18A1","PTGDS","ASPN","POSTN","GPC3","TNN","SFRP1","ACTA2","TAGLN","RGS5","MYL9","TPM2","RERGL","PECAM1","SELE","CLDN5","VWF","PROX1","LYVE1","HLA-DRA","FCER1G","TYROBP","AIF1","CD1C","CD207","CD68","RNASE1","SEPP1","ITGAX","CD3D","CD3E","CD52","IL7R","DCT","MLANA","PMEL","TYP1","CDH19","NGFR","UBE2C","PCNA")
# 
# for (i in 1:length(known_markers)) {
#   idx <- grep(known_markers[i], data_markers, fixed=TRUE)
# 
#   found <- c()
#   not_found <- c()
#   
#   if (any(is.na(idx))) {
#     not_found <- c(not_found, known_markers[i])
#   } else {
#     found <- c(found, known_markers[i])
#   }
# }
# 
# print(paste("Done:", length(not_found), "/", length(known_markers), "markers not found"))
```
