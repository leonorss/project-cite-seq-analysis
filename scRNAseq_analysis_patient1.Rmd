---
title: "scRNAseq analysis of Levesque’s data"
author: "Jonathan Haab"
date: "22 12 2020"
output: html_document
---
# from pipeline example described by Pierre-Luc Germain, course sta426 UZH

# Loading necessary libraries

```{r}
suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(scran)
  library(scater)
  library(batchelor)
  library(scDblFinder)
  library(sctransform)
  library(muscat)
  library(SEtools)
  library(cowplot)
  library(BiocParallel)
  library(ComplexHeatmap)
  
  library(DropletUtils) # for read10xCounts
  library(Matrix) # to handle sparse matrix
  library(BiocNeighbors) # for kNN graph
  library(igraph) # for cluster_louvain
})
```

# Preprocessing & Clustering

## Loading the data

```{r data-loading}
## data can be downloaded from : http://imlspenticton.uzh.ch/dump/files_for_levesque.tar

# set local path
local.path <- getwd()
setwd(local.path)
experiments <- array()
patient1_HS.path <- file.path("data", "patient1_HS")
patient1_SCC.path <- file.path("data", "patient1_SCC")
patient2_HS.path <- file.path("data", "patient2_HS")
patient2_AK.path <- file.path("data", "patient2_AK")




# read in filtered data and create list of SingleCellExperiment objects
paths <- list(patient1_HS.path, patient1_SCC.path, patient2_HS.path, patient2_AK.path)
sces <- lapply(paths, function(i) read10xCounts(file.path(i, "outs/filtered_feature_bc_matrix"), col.names = TRUE))

fnameHS <- file.path(patient1_HS.path, "outs/filtered_feature_bc_matrix")
#fnameSCC <- file.path(patient1_SCC.path, "outs/filtered_feature_bc_matrix")

# single cell experiment
sce.patient1_HS <- read10xCounts(fnameHS, col.names=TRUE)
#sce.patient1_SCC <- read10xCounts(fnameSCC, col.names=TRUE)

#sce.patient1_HS
#sce.patient1_SCC
```

```{r split-data}
# only select the gene expression data, drop the antibody capture
sces <- lapply(sces, function(i) i[rowData(i)$Type == "Gene Expression"])
sce.patient1_HS <- sce.patient1_HS[rowData(sce.patient1_HS)$Type == "Gene Expression"]
#sce.patient1_SCC <- sce.patient1_SCC[rowData(sce.patient1_SCC)$Type == "Gene Expression"]

sces <- lapply(sces, function(i) splitAltExps(i, rowData(i)$Type))
#lapply(sces, function(i) counts(altExp(i)) <- as.matrix(counts(altExp(i))))

# Split the data, store ADT in alternative experiment
sce.patient1_HS <- splitAltExps(sce.patient1_HS, rowData(sce.patient1_HS)$Type)
#sce.patient1_SCC <- splitAltExps(sce.patient1_SCC, rowData(sce.patient1_SCC)$Type)

# Coerce sparse matrix for ADT into a dense matrix
counts(altExp(sce.patient1_HS)) <- as.matrix(counts(altExp(sce.patient1_HS)))
#counts(altExp(sce.patient1_SCC)) <- as.matrix(counts(altExp(sce.patient1_SCC)))

```


## Normalization & reduction
Note : The presence of composition biases already implies strong differences in expression profiles, so changing the normalization strategy is unlikely to affect the outcome of a clustering procedure.

Library size normalization : assumes that there is no “imbalance” in the differentially expressed (DE) genes between any pair of cells. However, balanced DE is not generally present in scRNA-seq applications, which means that library size normalization may not yield accurate normalized expression values for downstream analyses. In practice, normalization accuracy is not a major consideration for exploratory scRNA-seq data analyses. Composition biases do not usually affect the separation of clusters, only the magnitude - and to a lesser extent, direction - of the log-fold changes between clusters or cell types. As such, library size normalization is usually sufficient in many applications where the aim is to identify clusters and the top markers that define each cluster.

```{r eval=FALSE}
#exlude genes that appeared in less than 5 cells
#sce.patient1_HS <- sce[rowData(sce.patient1_HS)$detected >= 5,]

keep_feature <- rowSums(counts(sce.patient1_HS) > 0) > 4
sce.patient1_HS <- sce.patient1_HS[keep_feature,]

lib.sf.HS <- librarySizeFactors(sce.patient1_HS)
summary(lib.sf.HS)
hist(log10(lib.sf.HS), xlab="Log10[Size factor]", col='grey80')
```


```{r scaling_logtransform, eval=FALSE}
set.seed(100)
clust.patient1_HS <- quickCluster(sce.patient1_HS) 
sce.patient1_HS <- computeSumFactors(sce.patient1_HS, cluster=clust.patient1_HS, min.mean=0.1)
# downsample to correct the effect of library size
sce.patient1_HS <- logNormCounts(sce.patient1_HS) 
#sce.patient1_HS <- logNormCounts(sce.patient1_HS, downsample=TRUE) 
assayNames(sce.patient1_HS)

sce.patient1_HS <- runPCA(sce.patient1_HS)
plotPCA(sce.patient1_HS)
```
=> log transfo doesn't give satisfying results, we'll try variance-stabilizing transformation

```{r vst}
# get rid of seldom detected genes
#keep_feature <- rowSums(counts(sce.patient1_HS) > 0) > 4
#sce.patient1_HS <- sce.patient1_HS[keep_feature,]

sces <- lapply(sces, function(i) i[(rowSums(counts(sce.patient1_HS) > 0) > 4),])

sce.patient1_HS <- sce.patient1_HS[(rowSums(counts(sce.patient1_HS) > 0) > 4),]
sce.patient1_SCC <- sce.patient1_SCC[(rowSums(counts(sce.patient1_SCC) > 0) > 4),]

vsts <- lapply(sces, function(i) suppressWarnings(sctransform::vst(counts((i)))))

vst.patient2_HS <- suppressWarnings(sctransform::vst(counts(sces[[3]])))

vst.patient1_HS <- suppressWarnings(sctransform::vst(counts(sce.patient1_HS)))
vst.patient1_SCC <- suppressWarnings(sctransform::vst(counts(sce.patient1_SCC)))

#logcounts(sce.patient1_HS) <- as.matrix(logcounts(sce.patient1_HS))
#nrow(vst.patient1_HS$y)
#ncol(vst.patient1_HS$y)
#nrow(counts(sce.patient1_HS))

for (i in seq_along(sces)) {
  logcounts(s[i], withDimnames=FALSE) <- vsts[i]$y
}

logcounts(sce.patient1_HS, withDimnames=FALSE) <- vst.patient1_HS$y
logcounts(sce.patient1_SCC, withDimnames=FALSE) <- vst.patient1_SCC$y

#assay(sce.patient1_HS, "vst") <- vst.patient1_HS$y
assays(sce.patient1_HS)
assays(sce.patient1_SCC)

# get highly-variable genes
hvg.patient1_HS <- row.names(sce.patient1_HS)[order(vst.patient1_HS$gene_attr$residual_variance, decreasing=TRUE)[1:2000]]
hvg.patient1_SCC <- row.names(sce.patient1_SCC)[order(vst.patient1_SCC$gene_attr$residual_variance, decreasing=TRUE)[1:2000]]
```

```{r pca}
# run PCA
sce.patient1_HS <- runPCA(sce.patient1_HS, subset_row=hvg.patient1_HS)
sce.patient1_SCC <- runPCA(sce.patient1_SCC, subset_row=hvg.patient1_SCC)

# check the variance explained by the PCs:
pc.var.patient1_HS <- attr(reducedDim(sce.patient1_HS),"percentVar")
plot(pc.var.patient1_HS, xlab="PCs", ylab="% variance explained")

pc.var.patient1_SCC <- attr(reducedDim(sce.patient1_SCC),"percentVar")
plot(pc.var.patient1_SCC, xlab="PCs", ylab="% variance explained")

# restrict to the first 20 components:
reducedDim(sce.patient1_HS) <- reducedDim(sce.patient1_HS)[,1:20]
reducedDim(sce.patient1_SCC) <- reducedDim(sce.patient1_SCC)[,1:20]

# run and plot 2d projections based on the PCA:
sce.patient1_HS <- runTSNE(sce.patient1_HS, dimred="PCA")
sce.patient1_HS <- runUMAP(sce.patient1_HS, dimred="PCA")

sce.patient1_SCC <- runTSNE(sce.patient1_SCC, dimred="PCA")
sce.patient1_SCC <- runUMAP(sce.patient1_SCC, dimred="PCA")

```

## Clustering

```{r clustering}
g.patient1_HS <- buildKNNGraph(sce.patient1_HS, BNPARAM=AnnoyParam(), use.dimred="PCA", k=30)
sce.patient1_HS$cluster <- as.factor(cluster_louvain(g.patient1_HS)$membership)

plot_grid( plotTSNE(sce.patient1_HS, colour_by="cluster", text_by="cluster"),
           plotUMAP(sce.patient1_HS, colour_by="cluster", text_by="cluster") )

```

# Cluster annotation

## Known markers

```{r}
#head(sce.patient1_HS)
# access gene name, 21242 elements
#rowData(sce.patient1_HS)$ID
#rownames(sce.patient1_HS)
# acces marker name, 21242 elements
#rowData(sce.patient1_HS)$Symbol



genes <- list(
  # classification: https://www.sciencedirect.com/science/article/pii/S0923181120301985?via%3Dihub#bib0050
  # KERATINOCYTE
  keratinocyte = c("DSC3","DSP","LGALS7"),
  keratinocyte_basal = c("KRT5","KRT14","COL17A1"),
  keratinocyte_suprabasal = c("KRT1","KRT10"),
  keratinocyte_differentiated = c("LOR", "SPINK5"),
  keratinocyte_ORS = c("KRT6B"),
  keratinocyte_channel = c("GJB2","GJB6","ATP1B1"),
  keratinocyte_sebaceous_gland = c("MGST1","FASN"),
  keratinocyte_sweat_gland  = c("DCD","AQP5"),
  # FIBROBLAST
  fibroblast  = c("DCDN","LUM","MMP2"),
  # fibroblast subclassification  from: https://www.nature.com/articles/s42003-020-0922-4#
  fibroblast_secretory_reticular = c("WISP2","SLPI","CTHRC1","MFAP5","TSPAN8"),
  fibroblast_proinflammatory = c("CCL19","APOE","CXCL2","CXCL3","EFEMP1"),
  fibroblast_secretory_papillary = c("APCDD1","ID1","WIF1","COL18A1","PTGDS"),
  fibroblast_mesenchymal = c("ASPN","POSTN","GPC3","TNN","SFRP1"),
  # PERICYTE & vSMC
  pericytevSMC  = c("ACTA2","TAGLN"), #vSMC : vascular smooth muscel cell
  pericytevSMC_pericyte  = c("RGS5"),
  pericytevSMC_vSMC  = c("MYL9","TPM2","RERGL"),
  # ENDOTHELIAL CELL
  endothelial  = c("PECAM1","SELE","CLDN5","VWF"),
  endothelial_lymphatic  = c("PROX1","LYVE1"),
  # MYELOID CELL
  myeloid  = c("HLA-DRA","FCER1G","TYROBP","AIF1"),
  myeloid_dendritic  = c("CD1C"),
  myeloid_langerhans  = c("CD207"),
  myeloid_macrophage = c("CD68","RNASE1","SEPP1","ITGAX"),
  # LYMPHOCYTE
  lymphocyte  = c("CD3D","CD3E","CD52","IL7R"),
  # MELANOCYTE
  melanocyte  = c("DCT","MLANA","PMEL","TYP1"),
  # SCHWANN CELL
  schwann  = c("CDH19","NGFR"),
  # MITOTIC CELL
  mitotic  = c("UBE2C","PCNA")
)
# since the row.names of the object have also the ensembl id, we find the matching row names for each gene:
rownames(sce.patient1_HS) <- paste(rownames(sce.patient1_HS), rowData(sce.patient1_HS)$Symbol, sep = ".")
#rownames(sce.patient1_HS)
km.patient1_HS <- lapply(genes, FUN=function(g.patient1_HS) grep(paste0(g.patient1_HS, "$", collapse="|"), rownames(sce.patient1_HS), value=TRUE))
```

## Pseudo-bulk aggregation

```{r, eval=FALSE}
# mean logcounts by cluster:
pb.patient1_HS <- aggregateData(sce.patient1_HS, "logcounts", by=c("cluster"), fun="mean")
# build a heatmap of the mean logcounts of the known markers:
h1 <- pheatmap(assay(pb.patient1_HS)[unlist(km.patient1_HS),], annotation_row=data.frame(row.names=unlist(km.patient1_HS), type=rep(names(km.patient1_HS), lengths(km.patient1_HS))), split=rep(names(km.patient1_HS), lengths(km.patient1_HS)), cluster_rows=FALSE, scale="row")
h1
# heatmap for the de-novo markers:
#h2 <- pheatmap(assay(pb.patient1_HS)[markers,], scale="row")
#h2
```

```{r}
# mean logcounts by cluster:
pb.patient1_HS <- aggregateData(sce.patient1_HS, "logcounts", by=c("cluster"), fun="mean")

# we will assign clusters to the cell type whose markers are the most expressed

# we extract the pseudo-bulk counts of the markers for each cluster
mat.patient1_HS <- assay(pb.patient1_HS)[unlist(km.patient1_HS),]
# we aggregate across markers of the same type
mat.patient1_HS <- aggregate(t(scale(t(mat.patient1_HS))), by=list(type=rep(names(km.patient1_HS), lengths(km.patient1_HS))), FUN=sum)
# for each column (cluster), we select the row (cell type) which has the maximum aggregated value
cl2.patient1_HS <- mat.patient1_HS[,1][apply(mat.patient1_HS[,-1], 2, FUN=which.max)]
# we convert the cells' cluster labels to cell type labels:
sce.patient1_HS$cluster2 <- cl2.patient1_HS[sce.patient1_HS$cluster]

# we aggregate again to pseudo-bulk using the new clusters
pb.patient1_HS <- aggregateData(sce.patient1_HS, "logcounts", by=c("cluster2"), fun="mean")
# we plot again the expression of the markers as a sanity check
h1 <- pheatmap(assay(pb.patient1_HS)[unlist(km.patient1_HS),], annotation_row=data.frame(row.names=unlist(km.patient1_HS), type=rep(names(km.patient1_HS), lengths(km.patient1_HS))), split=rep(names(km.patient1_HS), lengths(km.patient1_HS)), cluster_rows=FALSE, scale="row")

plotUMAP(sce.patient1_HS, colour_by="cluster2", text_by="cluster2")
```
